----------------------------Reverse Engineering-------------------------
Static disassemble:
	Linear sweep: creates assembly instructions from the binary based on fixed lenght of instructions, but in x86 we don't know a priori the lenght of instructions so it may not work correctly.
	Recursive: when there are instructions that change the control flow of the program I start to reconstruct instructions from where I land with the jump or similar instructions to fix the linear sweep problem.

Dynamic analisis:
	breakpoints: normal software breakpoints, those could be exploited to make them not work.			(b *address)	conditional: (b *address if $reg==val)
	hardware breakpoints: instruction level breapoints, if normal ones does not work we could run into those.	(hb *address)
	watchpoints: memory breakpoints: stop execution when reading or writing a certain address.	
	syscall catch: breakpoint when a specific syscall is executed.							(w *address) watch for write at addr, (rw *address) watch for read at addr
	signal catch: break when a signal is sent to the binary.
	scriptable: script the debugger (works with gdb) for hard exploitations.

	change values real time within the debugger: 
		change value of a register:   set $reg = val
		call a function:    call address

dynamic analisys prevention:
	debuggers like gdb uses a linux command to see and debug another program: ptrace, which can attach a program only to another one, so if the program attaches itself with ptrace, no debugger can analyze it.